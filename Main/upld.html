<!DOCTYPE html>
<htm lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Blood Report Analyzer</title>
        <!-- PDF.js library -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                margin: 0;
                padding: 0;
                background-color: #F9F9F9;
                color: #333;
            }

            .container {
                max-width: 900px;
                margin: 0 auto;
                padding: 20px;
            }

            header {
                background-color: #3b637d;
                color: white;
                padding: 1rem;
                text-align: center;
            }

            h1 {
                margin: 0;
                font-size: 28px;
            }

            /* Navigation bar styles (updated to center buttons) */
            nav {
                background-color: #87bdd8;
                padding: 1rem;
                text-align: center;
                /* Added to center the buttons */
            }

            /* nav a {
                color: white;
                margin: 0 1rem;
                text-decoration: none;
                font-weight: bold;
                font-family: Arial, sans-serif;
            } */

            .upload-section {
                background-color: white;
                padding: 30px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
                margin-bottom: 30px;
            }

            .file-input-wrapper {
                position: relative;
                margin: 20px 0;
                text-align: center;
            }

            .file-input {
                display: none;
            }

            .file-input-label {
                display: inline-block;
                background: linear-gradient(135deg, #2e7aad, #1f5f91);
                color: white;
                padding: 12px 20px;
                border-radius: 4px;
                cursor: pointer;
                transition: background 0.3s;
            }

            .file-input-label:hover {
                background: #143f6b;
            }

            .file-name {
                margin-top: 10px;
                font-size: 14px;
            }

            .button {
                background: linear-gradient(135deg, #2e7aad, #1f5f91);
                color: white;
                border: none;
                padding: 12px 20px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 16px;
                display: block;
                width: 100%;
                margin-top: 20px;
                transition: background 0.3s;
            }

            .button:hover {
                background: #143f6b;
            }

            .button:disabled {
                background-color: #95a5a6;
                cursor: not-allowed;
            }

            .results-section {
                background-color: white;
                padding: 30px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
                display: none;
            }

            nav a {
                color: white;
                margin: 0 1rem;
                text-decoration: none;
                font-weight: bold;
                font-size: 1.1rem;
                padding: 8px 12px;
                border-radius: 5px;
                transition: background 0.3s;
                font-family: Arial, sans-serif;
            }

            nav a:hover {
                background-color: #1f5f91;
            }

            #logoutBtn {
                cursor: pointer;
            }

            #logoutBtn:hover {
                background-color: #dc3545;
            }


            #analysisContent {
                padding: 20px;
                background-color: white;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-size: 18px;
            }

            .loader {
                border: 4px solid #f3f3f3;
                border-top: 4px solid #3498db;
                border-radius: 50%;
                width: 30px;
                height: 30px;
                animation: spin 2s linear infinite;
                margin: 20px auto;
                display: none;
            }

            pre#extractedTextContent {
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: monospace;
                line-height: 1.5;
                padding: 15px;
                background-color: #f8f9fa;
                border: 1px solid #ddd;
                border-radius: 4px;
                max-height: 500px;
                overflow-y: auto;
            }

            @keyframes spin {
                0% {
                    transform: rotate(0deg);
                }

                100% {
                    transform: rotate(360deg);
                }
            }

            /* Enhanced styling for analysis results */
            .patient-info {
                background-color: #e8f4f8;
                padding: 15px;
                border-radius: 5px;
                margin-bottom: 20px;
                border-left: 5px solid #3498db;
            }

            .patient-info-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 10px;
            }

            .patient-info-item {
                margin-bottom: 5px;
            }

            .results-table {
                width: 100%;
                border-collapse: collapse;
                margin-bottom: 20px;
            }

            .results-table th {
                background-color: #f8f9fa;
                padding: 10px;
                text-align: left;
                border-bottom: 2px solid #ddd;
            }

            .results-table td {
                padding: 8px 10px;
                border-bottom: 1px solid #ddd;
            }

            .normal {
                color: #28a745 !important;
                /* Green color */
            }

            .high {
                color: #dc3545 !important;
                /* Red for high */
                font-weight: bold !important;
            }

            .low {
                color: #e67e22 !important;
                /* Orange for low */
                font-weight: bold !important;
            }

            .section-title {
                margin-top: 25px;
                margin-bottom: 15px;
                color: #2c3e50;
                border-bottom: 2px solid #eee;
                padding-bottom: 5px;
            }

            .summary-section {
                background-color: #f8f9fa;
                padding: 15px;
                border-radius: 5px;
                margin-top: 20px;
            }

            .recommendations {
                background-color: #e8f8f5;
                padding: 15px;
                border-radius: 5px;
                margin-top: 20px;
                border-left: 5px solid #2ecc71;
            }

            .disclaimer {
                font-size: 12px;
                color: #6c757d;
                margin-top: 20px;
                padding-top: 10px;
                border-top: 1px solid #ddd;
            }

            .info-message {
                text-align: center;
                color: #6c757d;
            }

            .error-message {
                color: #dc3545;
                margin-top: 10px;
                display: none;
            }

            /* Button styles for the progress button */
            .button-container {
                display: flex;
                gap: 15px;
                margin-top: 20px;
            }

            .progress-button {
                background: linear-gradient(135deg, #2e7aad, #1f5f91);
                flex: 1;
            }

            .progress-button:hover {
                background: #143f6b;
            }

            .print-button {
                flex: 1;
            }

            .Login {
                position: absolute;
                top: 1rem;
                right: 1rem;
            }

            .user-info-link {
                text-decoration: none;
                color: white;
            }

            .user-info {
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .profile-pic {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                object-fit: cover;
            }

            .username {
                font-size: 16px;
                font-weight: bold;
            }

            /* Add this at the end of the existing <style> section */
            @media (max-width: 768px) {
                .container {
                    padding: 10px;
                    /* Reduce padding for smaller screens */
                }

                header {
                    padding: 0.5rem;
                    /* Reduce header padding */
                }

                header h1 {
                    font-size: 20px;
                    /* Smaller header text */
                }

                header p {
                    font-size: 14px;
                    /* Smaller subtext */
                }

                nav {
                    padding: 0.5rem;
                    /* Reduce nav padding */
                    display: flex;
                    /* Ensure horizontal scrolling or stacking */
                    flex-wrap: wrap;
                    /* Allow wrapping if needed */
                    justify-content: center;
                }

                nav a {
                    margin: 0.5rem;
                    /* Reduce margin between nav items */
                    padding: 6px 10px;
                    /* Smaller padding for nav links */
                    font-size: 0.9rem;
                    /* Smaller font size */
                }

                .upload-section,
                .results-section {
                    padding: 15px;
                    /* Reduce padding */
                }

                .file-input-label,
                .button {
                    padding: 10px 15px;
                    /* Smaller buttons */
                    font-size: 14px;
                    /* Smaller button text */
                }

                .button-container {
                    flex-direction: column;
                    /* Stack buttons vertically */
                    gap: 10px;
                    /* Reduce gap */
                }

                .Login {
                    top: 0.5rem;
                    /* Adjust login position */
                    right: 0.5rem;
                }

                .profile-pic {
                    width: 30px;
                    /* Smaller profile picture */
                    height: 30px;
                }

                .username {
                    font-size: 12px;
                    /* Smaller username text */
                }

                /* Ensure table is scrollable on small screens */
                .results-table {
                    display: block;
                    overflow-x: auto;
                    white-space: nowrap;
                }
            }

            @media (max-width: 480px) {
                header h1 {
                    font-size: 18px;
                }

                nav a {
                    font-size: 0.8rem;
                    padding: 5px 8px;
                }

                .file-input-label,
                .button {
                    padding: 8px 12px;
                    font-size: 12px;
                }

                .patient-info-grid {
                    grid-template-columns: 1fr;
                    /* Single column on very small screens */
                }
            }
        </style>
    </head>

    <body>
        <header>
            <div class="Login">
                <a href="profile.html" class="user-info-link">
                    <div class="user-info">
                        <img src="" alt="Profile Picture" class="profile-pic" id="profilePic">
                        <span class="username" id="username"></span>
                    </div>
                </a>
            </div>
            <h1>Upload Your Blood Report</h1>
            <p>Analyze your blood test PDF quickly and easily.</p>
        </header>

        <nav>
            <a href="home.html">Home</a>
            <a href="progress.html">Track Progress</a>
            <a href="diet&exercise.html">Diet & Exercise</a>
            <a href="storage.html" aria-label="Storage">Storage</a>
            <a href="#" id="logoutBtn" aria-label="Logout">Logout</a>

        </nav>

        <div class="container">
            <div class="upload-section">
                <h2>Upload Blood Test Report</h2>
                <p>Please upload your blood test report in PDF format to get started.</p>
                <div class="file-input-wrapper">
                    <input type="file" id="pdfFile" class="file-input" accept=".pdf">
                    <label for="pdfFile" class="file-input-label">Choose PDF File</label>
                    <div id="fileName" class="file-name">No file chosen</div>
                </div>
                <div class="help-text">Maximum file size: 10MB. For optimal results, ensure your PDF contains text data
                    (not
                    scanned images).</div>
                <button id="analyzeButton" class="button" disabled>Analyze Report</button>
                <div id="errorMessage" class="error-message"></div>
                <div id="loader" class="loader"></div>
            </div>

            <div id="results" class="results-section">
                <h2>Analysis Results</h2>
                <div id="analysisContent"></div>
                <div class="button-container">
                    <button id="progressButton" class="button progress-button">View Progress Charts</button>
                    <button id="printButton" class="button print-button">Print Report</button>
                </div>
            </div>
        </div>
    </body>



    <script type="module">

        import { supabase } from "./scripts/config.js";
        import { db } from "./scripts/firebase-storage-config.js";
        import { getCurrentUserId } from "./scripts/user-data-service.js";
        import {
            collection,
            addDoc,
            Timestamp
        } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-firestore.js";
        import { checkAuthAndRedirect, displayUserInfo, handleLogout } from './scripts/auth.js';


        document.addEventListener('DOMContentLoaded', function () {
            let currentAnalysisData = null;
            let userProfile = null; // To store user profile data

            // Fetch authenticated user profile data
            async function fetchUserProfile() {
                try {
                    const { data: { user }, error } = await supabase.auth.getUser();
                    if (error) throw error;
                    if (!user) {
                        console.error("No authenticated user found");
                        window.location.href = 'login.html'; // Redirect to login if not authenticated
                        return null;
                    }
                    // Return user metadata (fullName, birthdate, gender, weight, height, medicalInfo, etc.)
                    return user.user_metadata || {};
                } catch (error) {
                    console.error('Error fetching user profile:', error);
                    return null;
                }
            }

            // Initialize the page with user data
            async function initPage() {
                const isLoggedIn = await checkAuthAndRedirect();
                if (!isLoggedIn) return;

                userProfile = await fetchUserProfile();
                if (!userProfile) {
                    console.warn("User profile not loaded; proceeding with default analysis.");
                } else {
                    console.log("User profile loaded:", userProfile);
                }
            }

            // Call initPage when the DOM is loaded
            initPage();

            // Set the workerSrc property to load worker from CDN
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

            const pdfFile = document.getElementById('pdfFile');
            const fileName = document.getElementById('fileName');
            const analyzeButton = document.getElementById('analyzeButton');
            const loader = document.getElementById('loader');
            const results = document.getElementById('results');
            const analysisContent = document.getElementById('analysisContent');
            const errorMessage = document.getElementById('errorMessage');
            const printButton = document.getElementById('printButton');
            const progressButton = document.getElementById('progressButton');

            // API key - replace with your actual key
            const API_KEY = 'AIzaSyCaBpjdVtlzriQUljPhAmxRem49DNBPFGU';

            // Handle file selection
            pdfFile.addEventListener('change', function (e) {
                if (pdfFile.files.length > 0) {
                    const file = pdfFile.files[0];

                    // Check file size (limit to 10MB)
                    if (file.size > 10 * 1024 * 1024) {
                        fileName.textContent = 'File too large (max 10MB)';
                        errorMessage.textContent = 'The selected file exceeds the maximum size limit of 10MB.';
                        errorMessage.style.display = 'block';
                        analyzeButton.disabled = true;
                        return;
                    }

                    // Check file type
                    if (file.type !== 'application/pdf') {
                        fileName.textContent = 'Invalid file type';
                        errorMessage.textContent = 'Please select a valid PDF file.';
                        errorMessage.style.display = 'block';
                        analyzeButton.disabled = true;
                        return;
                    }

                    fileName.textContent = file.name;
                    errorMessage.style.display = 'none';
                    analyzeButton.disabled = false;
                } else {
                    fileName.textContent = 'No file chosen';
                    analyzeButton.disabled = true;
                }
            });

            // Handle print button
            printButton.addEventListener('click', function () {
                window.print();
            });

            // Handle progress button click
            progressButton.addEventListener('click', function () {
                window.location.href = 'progress.html';
            });

            async function extractTextFromPDF(file) {
                return new Promise((resolve, reject) => {
                    const fileReader = new FileReader();

                    fileReader.onload = async function () {
                        try {
                            const typedArray = new Uint8Array(this.result);

                            // Load the PDF document
                            const loadingTask = pdfjsLib.getDocument({ data: typedArray });
                            const pdf = await loadingTask.promise;

                            let extractedText = '';

                            // Extract text from each page
                            for (let i = 1; i <= pdf.numPages; i++) {
                                const page = await pdf.getPage(i);
                                const textContent = await page.getTextContent();

                                // Process text with better line break handling
                                let lastY = null;
                                let pageText = '';
                                let currentLine = '';

                                // Process each text item
                                for (const item of textContent.items) {
                                    // Check if we need a new line based on Y position
                                    if (lastY !== null && Math.abs(lastY - item.transform[5]) > 5) {
                                        pageText += currentLine + '\n';
                                        currentLine = '';
                                    }

                                    // Add appropriate spacing between words on the same line
                                    if (currentLine && currentLine[currentLine.length - 1] !== ' ' &&
                                        item.str && item.str[0] !== ' ' &&
                                        !currentLine.endsWith('-')) {
                                        currentLine += ' ';
                                    }

                                    currentLine += item.str;
                                    lastY = item.transform[5];
                                }

                                // Add the last line
                                if (currentLine) {
                                    pageText += currentLine;
                                }

                                // Add page number and text with proper spacing
                                extractedText += `\n----- PAGE ${i} -----\n\n${pageText}\n\n`;
                            }

                            resolve(extractedText);
                        } catch (error) {
                            console.error('PDF.js error:', error);
                            reject(new Error('Failed to extract text from PDF: ' + error.message));
                        }
                    };

                    fileReader.onerror = function (error) {
                        console.error('FileReader error:', error);
                        reject(new Error('Failed to read file'));
                    };

                    fileReader.readAsArrayBuffer(file);
                });
            }

            // Helper function to convert file to base64
            function fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = error => reject(error);
                });
            }

            // Function to send PDF directly to Gemini
            async function sendPDFToGemini(file) {
                try {
                    const base64PDF = await fileToBase64(file);
                    const base64Data = base64PDF.split('base64,')[1];
                    if (!base64Data) throw new Error('Failed to convert PDF to base64 format');

                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${API_KEY}`;

                    let age = null;
                    if (userProfile?.birthdate) {
                        const birthDate = new Date(userProfile.birthdate);
                        age = new Date().getFullYear() - birthDate.getFullYear();
                    }

                    const instructions = `
Analyze this PDF and first determine if it is a blood test report. If it is not a blood test report, return this exact message as the first line followed by an additional line:
<div class="error-message">This document does not appear to be a blood test report.</div>
<div>Please upload a valid blood test report PDF for analysis.</div>

If it is a blood test report, proceed with the following analysis:
- Extract and present patient information first (name, age, sex, ID, etc.) in a structured format. Blur out major portions of the patient's full name and ID for privacy.
- Extract test results and present them in a table with these columns:
  - Test Name/Parameter
  - Result (numeric value only, after interpreting units)
  - Unit (e.g., gm/dl, millions/cumm, x1000/cumm, etc.)
  - Reference Range (numeric range after interpreting units)
  - Status (must be one of: Normal, High, Low, or Borderline)
- For test values with "x1000/cumm" (e.g., Platelet Count (PLC), Total Leucocyte Count (TLC)):
  - Interpret the value by multiplying by 1000 (e.g., "251 x1000/cumm" should be extracted as 251000).
  - Interpret the reference range in the same unit (e.g., "150 - 450" for PLC means 150000 - 450000).
  - Compare the adjusted value to the adjusted range to determine the status.
  After extracting and determining the status of all test results, sort the rows in the table in the following order of priority: High first, then Low, then Borderline, and finally Normal.
- For each abnormal value (High or Low), provide a brief interpretation (1-2 lines max) in a separate section, considering the user's age, gender, weight, height, and medical history:
  - Age: ${age || 'Not provided'}
  - Gender: ${userProfile?.gender || 'Not provided'}
  - Weight: ${userProfile?.weight ? `${userProfile.weight} kg` : 'Not provided'}
  - Height: ${userProfile?.height ? `${userProfile.height} cm` : 'Not provided'}
  - Medical History: ${userProfile?.medicalInfo || 'Not provided'}
- Provide 3-4 personalized recommendations based on abnormal findings and the user profile.
- Format your response as HTML - DO NOT include code block markers.

Use this structure and these HTML classes:
- <div class="patient-info"> for patient details
- <h3 class="section-title"> for section headers
- <table class="results-table"> for test results
- <div class="summary-section"> for abnormal findings summary
- <div class="recommendations"> for recommendations
- For the Status column, apply these classes to the <td> element:
  - class="normal" for Normal
  - class="high" for High
  - class="low" for Low
  - class="borderline" for Borderline
`;

                    const requestBody = {
                        contents: [{
                            parts: [
                                { text: instructions },
                                {
                                    inline_data: {
                                        mime_type: "application/pdf",
                                        data: base64Data
                                    }
                                }
                            ]
                        }],
                        generationConfig: {
                            maxOutputTokens: 2048,
                            temperature: 0.2,
                            topP: 0.8,
                            topK: 40,
                        }
                    };

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`API responded with status ${response.status}: ${JSON.stringify(errorData)}`);
                    }

                    const data = await response.json();
                    if (!data.candidates || data.candidates.length === 0) {
                        throw new Error('No response generated from Gemini API');
                    }

                    let result = "";
                    data.candidates.forEach(candidate => {
                        candidate.content.parts.forEach(part => {
                            if (part.text) result += part.text;
                        });
                    });

                    return result.replace(/```html/g, '').replace(/```/g, '');
                } catch (error) {
                    console.error('Gemini API Error:', error);
                    throw new Error('Failed to analyze with Gemini API: ' + error.message);
                }
            }

            function extractTestValues(rawText, analysisHTML) {
                let extractedValues = {};

                // Parse the HTML to extract values from the table
                const parser = new DOMParser();
                const doc = parser.parseFromString(analysisHTML, 'text/html');
                const tables = doc.querySelectorAll('table.results-table');

                if (tables.length === 0) {
                    console.warn("No results table found in analysis HTML");

                    // Fallback to regex extraction if no table found
                    const regexPatterns = {
                        "Hemoglobin": /H(?:b|emoglobin)\s+(\d+\.?\d*)\s*(?:g\/dL|gm\/dL)/i,
                        "RBC count": /RBC\s+(?:count)?\s+(\d+\.?\d*)/i,
                        "Glucose": /(?:Glucose|FBS|Blood sugar)\s+(\d+\.?\d*)/i,
                        "CRP": /CRP\s+(?:\(C reactive\s+protein\))?\s+(\d+\.?\d*)\s*mg\/L/i,
                        "WBC count": /(?:WBC|TLC)\s+(?:count)?\s+(\d+\.?\d*)/i,
                        "Platelets": /(?:Platelet|PLC)\s+(?:count)?\s+(\d+\.?\d*)/i,
                        "HbA1c": /HbA1c\s+(\d+\.?\d*)/i,
                        "Creatinine": /Creatinine\s+(\d+\.?\d*)/i,
                        "Cholesterol": /Cholesterol\s+(?:total)?\s+(\d+\.?\d*)/i,
                        "Triglycerides": /Triglycerides\s+(\d+\.?\d*)/i,
                        "HDL": /HDL\s+(?:cholesterol)?\s+(\d+\.?\d*)/i,
                        "LDL": /LDL\s+(?:cholesterol)?\s+(\d+\.?\d*)/i,
                        "VLDL": /VLDL\s+(?:cholesterol)?\s+(\d+\.?\d*)/i,
                        "ESR": /ESR\s+(\d+\.?\d*)/i,
                        "BUN": /(?:BUN|Blood Urea Nitrogen)\s+(\d+\.?\d*)/i,
                        "Uric Acid": /Uric Acid\s+(\d+\.?\d*)/i,
                        "Sodium": /Sodium\s+(\d+\.?\d*)/i,
                        "Potassium": /Potassium\s+(\d+\.?\d*)/i,
                        "Calcium": /Calcium\s+(\d+\.?\d*)/i,
                        "Total Protein": /Total Protein\s+(\d+\.?\d*)/i,
                        "Albumin": /Albumin\s+(\d+\.?\d*)/i,
                        "Globulin": /Globulin\s+(\d+\.?\d*)/i,
                        "AST": /(?:AST|SGOT)\s+(\d+\.?\d*)/i,
                        "ALT": /(?:ALT|SGPT)\s+(\d+\.?\d*)/i,
                        "ALP": /(?:ALP|Alkaline Phosphatase)\s+(\d+\.?\d*)/i,
                        "Bilirubin": /Bilirubin\s+(?:total)?\s+(\d+\.?\d*)/i,
                        "TSH": /TSH\s+(\d+\.?\d*)/i
                    };

                    for (let test in regexPatterns) {
                        let match = rawText.match(regexPatterns[test]);
                        if (match) {
                            extractedValues[test] = parseFloat(match[1]);
                        }
                    }

                    return extractedValues;
                }

                // Map test names to keys for extractedValues
                const testNameMap = {
                    "hb": "Hemoglobin",
                    "hemoglobin": "Hemoglobin",
                    "hct": "PCV",
                    "pcv": "PCV",
                    "hematocrit": "PCV",
                    "rbc count": "RBC count",
                    "rbc": "RBC count",
                    "tlc": "WBC count",
                    "wbc count": "WBC count",
                    "wbc": "WBC count",
                    "plc": "Platelets",
                    "platelet count": "Platelets",
                    "platelets": "Platelets",
                    "glucose": "Glucose",
                    "fbs": "Glucose",
                    "random glucose": "Glucose",
                    "hba1c": "HbA1c",
                    "creatinine": "Creatinine",
                    "cholesterol": "Cholesterol",
                    "total cholesterol": "Cholesterol",
                    "triglycerides": "Triglycerides",
                    "hdl": "HDL",
                    "hdl cholesterol": "HDL",
                    "ldl": "LDL",
                    "ldl cholesterol": "LDL",
                    "vldl": "VLDL",
                    "vldl cholesterol": "VLDL",
                    "crp": "CRP",
                    "c-reactive protein": "CRP",
                    "esr": "ESR",
                    "bun": "BUN",
                    "blood urea nitrogen": "BUN",
                    "uric acid": "Uric Acid",
                    "sodium": "Sodium",
                    "potassium": "Potassium",
                    "calcium": "Calcium",
                    "total protein": "Total Protein",
                    "albumin": "Albumin",
                    "globulin": "Globulin",
                    "ast": "AST",
                    "sgot": "AST",
                    "alt": "ALT",
                    "sgpt": "ALT",
                    "alp": "ALP",
                    "alkaline phosphatase": "ALP",
                    "bilirubin": "Bilirubin",
                    "total bilirubin": "Bilirubin",
                    "tsh": "TSH",
                    "thyroid stimulating hormone": "TSH"
                };

                tables.forEach(table => {
                    const rows = Array.from(table.querySelectorAll('tr')).slice(1); // Skip header
                    rows.forEach(row => {
                        const cells = row.querySelectorAll('td');
                        if (cells.length < 5) return; // Expecting 5 columns: Test Name, Result, Unit, Reference Range, Status

                        const testName = cells[0].textContent.trim().toLowerCase();
                        const resultText = cells[1].textContent.trim();
                        const resultValue = parseFloat(resultText);

                        if (isNaN(resultValue)) return;

                        // Map the test name to the key used in extractedValues
                        for (const key in testNameMap) {
                            if (testName.includes(key)) {
                                const standardTestName = testNameMap[key];
                                extractedValues[standardTestName] = resultValue;
                                break;
                            }
                        }
                    });
                });

                console.log("Extracted test values from HTML table:", extractedValues);
                return extractedValues;
            }

            async function saveProcessedReport(rawText, analysisHTML) {
                try {
                    const userId = await getCurrentUserId();
                    if (!userId) {
                        console.error("User not authenticated");
                        return null;
                    }

                    // Extract test values from the HTML table
                    let extractedValues = extractTestValues(rawText, analysisHTML);

                    // Create document data
                    const reportData = {
                        date: Timestamp.now(),
                        values: extractedValues,
                        analysisHTML: analysisHTML,
                        rawText: rawText
                    };

                    // 1. Upload PDF to Supabase storage
                    let supabaseFileUrl = null;
                    if (pdfFile.files.length > 0) {
                        try {
                            const file = pdfFile.files[0];
                            const fileExt = file.name.split('.').pop();
                            const userId = await getCurrentUserId();
                            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                            const filePath = `${userId}/${timestamp}_${file.name}`;

                            console.log("Uploading file to Supabase storage:", filePath);

                            // Get the current authenticated user
                            const { data: { user } } = await supabase.auth.getUser();

                            if (!user) {
                                console.error("No authenticated user found");
                                throw new Error("Authentication required for file upload");
                            }

                            // Upload to Supabase Storage 
                            const { data: uploadData, error: uploadError } = await supabase.storage
                                .from('blood-reports')
                                .upload(`public/${filePath}`, file, {
                                    cacheControl: '3600',
                                    upsert: true,
                                    contentType: file.type
                                });

                            if (uploadError) {
                                console.error("Supabase storage upload error:", uploadError);

                                // If bucket requires authenticated access for public folder
                                if (uploadError.statusCode === 400 || uploadError.statusCode === 403) {
                                    console.log("Attempting upload to authenticated folder...");

                                    // Create folder with user ID if it doesn't exist
                                    const userFolder = `${user.id}`;

                                    const { data: userUploadData, error: userUploadError } = await supabase.storage
                                        .from('blood-reports')
                                        .upload(`${userFolder}/${filePath}`, file, {
                                            upsert: true,
                                            contentType: file.type
                                        });

                                    if (userUploadError) {
                                        console.error("User folder upload also failed:", userUploadError);
                                        throw userUploadError;
                                    } else {
                                        console.log("File uploaded to user folder successfully:", userUploadData);

                                        // Get the URL - use createSignedUrl for private buckets
                                        const { data: urlData, error: urlError } = await supabase.storage
                                            .from('blood-reports')
                                            .createSignedUrl(`${userFolder}/${filePath}`, 60 * 60 * 24 * 365); // 1 year expiry

                                        if (urlError) {
                                            console.error("Error creating signed URL:", urlError);
                                        } else if (urlData) {
                                            supabaseFileUrl = urlData.signedUrl;
                                            console.log("Supabase signed file URL:", supabaseFileUrl);
                                        }
                                    }
                                } else {
                                    throw uploadError;
                                }
                            } else {
                                console.log("File uploaded to public folder successfully:", uploadData);

                                // Get the public URL of the uploaded file
                                const { data: urlData } = supabase.storage
                                    .from('blood-reports')
                                    .getPublicUrl(`public/${filePath}`);

                                if (urlData) {
                                    supabaseFileUrl = urlData.publicUrl;
                                    console.log("Supabase public file URL:", supabaseFileUrl);
                                }
                            }
                        } catch (storageError) {
                            console.error("Error uploading to Supabase storage:", storageError);
                            // Continue execution even if Supabase upload fails
                        }
                    }

                    // Add the Supabase file URL to the report data
                    if (supabaseFileUrl) {
                        reportData.pdfUrl = supabaseFileUrl;
                    }

                    // 2. Save to Firestore (as before)
                    const reportsRef = collection(db, "users", userId, "bloodReports");
                    const docRef = await addDoc(reportsRef, reportData);

                    console.log("Processed report saved with ID:", docRef.id);

                    // Return the saved report with ID
                    return {
                        id: docRef.id,
                        ...reportData,
                        date: reportData.date.toDate().toISOString()
                    };
                } catch (error) {
                    console.error("Error in saveProcessedReport():", error);
                    return null;
                }
            }

            function displayAnalysisResults(analysis) {
                // Clean any remaining markdown or code block markers
                let cleanedAnalysis = analysis.trim();

                // Apply the HTML formatting from the API response
                analysisContent.innerHTML = cleanedAnalysis;

                // Process all tables in the report to apply styling based on Gemini's classes
                const tables = analysisContent.querySelectorAll('table');
                tables.forEach(table => {
                    // Ensure table has proper styling
                    if (!table.classList.contains('results-table')) {
                        table.classList.add('results-table');
                    }

                    // Check if this is a results table with test values
                    const headerRow = table.querySelector('tr');
                    if (!headerRow) return;

                    const headers = Array.from(headerRow.querySelectorAll('th')).map(th =>
                        th.textContent.trim().toLowerCase());

                    // Find the column indices
                    const statusColIndex = headers.findIndex(h =>
                        h.includes('status') || h.includes('flag') || h.includes('class'));

                    if (statusColIndex === -1) return;

                    // Process each row in the table (skip header)
                    const rows = Array.from(table.querySelectorAll('tr')).slice(1);

                    rows.forEach(row => {
                        const cells = row.querySelectorAll('td');
                        if (cells.length <= statusColIndex) return;

                        const statusCell = cells[statusColIndex];
                        if (!statusCell) return;

                        // Apply styling based on the class assigned by Gemini
                        if (statusCell.classList.contains('high')) {
                            statusCell.style.color = '#dc3545'; // Red for high
                        } else if (statusCell.classList.contains('low')) {
                            statusCell.style.color = '#e67e22'; // Orange for low
                        } else if (statusCell.classList.contains('normal')) {
                            statusCell.style.color = '#28a745'; // Green for normal
                        } else if (statusCell.classList.contains('borderline')) {
                            statusCell.style.color = '#e67e22'; // Orange for borderline
                        }
                    });
                });

                // Make sure all links open in a new tab
                const links = analysisContent.querySelectorAll('a');
                links.forEach(link => {
                    link.setAttribute('target', '_blank');
                    link.setAttribute('rel', 'noopener noreferrer');
                });
            }

            // Handle analyze button click
            analyzeButton.addEventListener('click', async function () {
                if (pdfFile.files.length === 0) return;

                // Reset previous results
                analysisContent.innerHTML = '';

                // Show loader
                loader.style.display = 'block';
                analyzeButton.disabled = true;
                errorMessage.style.display = 'none';
                results.style.display = 'none'; // Hide results section until processing completes

                const file = pdfFile.files[0];

                try {
                    console.log("Starting analysis for file:", file.name);

                    // First extract the text to ensure we can read the PDF
                    const extractedText = await extractTextFromPDF(file);
                    console.log("PDF text extracted successfully, length:", extractedText.length);

                    if (!extractedText || extractedText.trim().length === 0) {
                        throw new Error("Could not extract text from PDF. The file may be scanned or protected.");
                    }

                    // Send PDF to Gemini API for analysis
                    console.log("Sending PDF to Gemini for analysis...");
                    const analysisResult = await sendPDFToGemini(file);
                    console.log("Analysis received from Gemini, length:", analysisResult.length);

                    // Display analysis results
                    displayAnalysisResults(analysisResult);
                    console.log("Analysis results displayed successfully");

                    // Save extracted text and values for progress tracking
                    try {
                        console.log("Saving processed report...");
                        const savedReport = await saveProcessedReport(extractedText, analysisResult);
                        if (savedReport) {
                            // Store the current analysis data in a global variable
                            currentAnalysisData = savedReport;

                            // Also store in sessionStorage for access across pages in the same session
                            sessionStorage.setItem('currentBloodAnalysis', JSON.stringify(currentAnalysisData));
                            console.log("Analysis data saved and ready for use");
                        } else {
                            console.warn("Failed to save analysis data");
                        }
                    } catch (saveError) {
                        console.error("Error saving report:", saveError);
                        // Continue even if saving fails
                    }

                    // Show results section
                    results.style.display = 'block';

                } catch (error) {
                    console.error('Error during analysis:', error);
                    errorMessage.textContent = 'An error occurred during processing: ' + error.message;
                    errorMessage.style.display = 'block';
                } finally {
                    // Hide loader
                    loader.style.display = 'none';
                    analyzeButton.disabled = false;
                }
            });

            // Handle go back button
            document.getElementById('goBackButton').addEventListener('click', function () {
                window.location.href = 'home.html'; // Change this to your actual homepage URL
            });
        });
    </script>
    </body>

    </html>